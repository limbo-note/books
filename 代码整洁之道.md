#1. 整洁代码
简单代码规则：

- 能通过所有测试
- 没有重复代码
- 体现系统中的全部设计理念
- 包括尽量少的实体，比如类、方法、函数等

# 2. 有意义的命名 #
### 2.2 名副其实
变量、函数或类的名称应该已经答复了所有的问题，应该说明为什么会存在，做什么事，应该怎么用
### 2.3 避免误导
### 2.4 做有意义的区分
**废话都是冗余**。Variable一词永远不应出现在变量名中
### 2.6 使用可搜索的名称
单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应。若变量或常量可能在代码中多处使用，则应使用便于搜索的名称

### 2.7 避免使用编码
HN和其他类型编码形式的命名都是多余的

**成员前缀**：也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要

###2.8 避免思维映射
使用别人熟知的名称。如，在作用域较小、也没有名称冲突时，循环计数器自然有可能被命名为i,j,k

###2.10 方法名
方法名应当是动词、动词短语。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set、is前缀

#3. 函数
###3.1 短小
if、else、while语句，其中的代码块应该只有一行，应该是一个函数调用语句；函数不应大到足以容纳嵌套结构，所以函数的缩进层级不应多于1层或2层

###3.2 只做一件事
函数应该做一件事。做好这件事，只做这一件事

###3.3 每个函数一个抽象层级
函数中的语句应该都要在同一抽象层级上

**自顶向下读代码——向下规则**：让代码拥有自顶向下的阅读顺序。让每个函数后面都跟着位于下一抽象层级的函数

###3.4 switch语句
将switch语句埋藏到抽象工厂底下

###3.5 使用描述性的名称
长而具有描述性的名称，比短却费解的名称要好

###3.6 函数参数
最理想的参数数量是0，其次是1，越多越不好；应尽量避免三个或三个以上的参数

###3.7 无副作用
函数不应该有副作用，如果一定要时序性耦合，就应该在函数名称中说明

应避免使用输出参数

###3.8 分隔指令与询问
一个函数要么做什么事，要么回答什么事，二者不可得兼。函数应该修改某对象的状态(set)，或是返回该对象的有关信息(get)。两样都干会导致混乱

###3.9 使用异常替代返回错误码
**抽离try/catch块**：最好把try/catch的代码块主体部分抽离出来另外形成函数  

**错误处理就是一件事**：函数应该只做一件事，错误处理就是一件事。因此，如果关键字try在某个函数中存在，就应该是这个函数的第一个单词，在try/catch块后面也不应该有其他内容

异常代替返回错误码可以避免因对错误枚举类修改，而需要对引用类全部进行修改的情况

###3.12 如何写
先想写什么写什么，然后再打磨已写的代码，分解函数、修改名称、消除重复

#4. 注释
在找不到用代码表达的情况下才需要写注释，不准确的注释比没注释坏得多；尽管有时候也需要注释，也该多花心思尽量减少注释量

###4.1 注释不能美化糟糕的代码
与其花时间写糟糕代码的注释，不如花时间清洁那堆糟糕的代码

###4.2 用代码来阐述
尽量用代码解释大部分的意图

###4.3 好注释
**法律信息**：源文件开头部分的版权和著作权声明

**提供信息的注释**：如返回值的说明，正则表达式的解释等

**对意图的解释**：解释某部分为什么要那样写代码，选取此方案的原因等

**警示**：警告其他程序员会出现某种后果

**TODO注释**：认为应该做，但是还没做的工作

**强调**：强调某处代码这样写的重要性

**javadoc**

###4.4 坏注释
**多余的注释**：不能比代码本身提供更多的信息，读注释的时间没准比读代码的时间更长

**误导性注释**：导致其他程序员不正确的使用某个函数

**循规式注释**：不是每个函数都要有javadoc或每个变量都要有注释，这些注释可能让代码变得散乱

**日志式注释**：代码更新的日志不应该在源文件中出现

**能用函数或变量时就别用注释**

**注释掉的代码**：用代码版本管理来记录代码的变化，不要的代码应该删去，不应该仅注释

**代码和注释的联系应该显而易见**

#5. 格式
###5.2 垂直格式
源文件大小不应过大，几百行左右可以接受。短文件通常比长文件易于理解

源文件应该像读报纸文章一样。名称应该简单一目了然，最顶部应该给出高层次概念和算法，细节应往下逐渐展开

**垂直间隔**：封包声明、导入声明和每个函数之间都应有空白行隔开；紧密相关的代码应该互相靠近

**变量声明**：变量声明应尽量靠近其使用位置。本地变量应该正好在其首次被使用的位置上面声明；循环控制的变量应该总在循环语句中声明；类变量通常在类的顶部声明

**相关函数**：某个函数调用了另外一个，应该把他们放在一起，而且调用者尽可能放在被调用者上面。（ **自顶向下**）  

**概念相关**：概念相关的函数代码应该放在一起。相关性越强，距离应该越短

###5.3 横向格式
行不宜太长。长度为100或120的上限

**水平方向的距离**：赋值操作符两边加空格。不在函数名和左括号之间加空格。函数中的参数在逗号后加空格

**水平对齐**：多行的声明和赋值不需要对齐

###5.4 团队规则
在一个团队中，就需要遵循团队的代码风格。统一的代码风格看起来很舒服

#6.对象和数据结构
###6.1 数据抽象
隐藏实现并非只是在变量上放上了一个函数层（如变量取值器、赋值器）。隐藏实现关乎抽象，应该是暴露抽象接口，以便用户无需了解数据的实现就能操作数据本体

###6.2 数据、对象的反对称性
过程式代码（使用数据结构的代码）便于在不改动现有数据结构的前提下添加新函数，而面向对象的代码便于在不改动现有函数的前提下添加新类；过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象的代码难以添加新函数，因为必须修改所有类

###6.3 得墨忒耳律
（.................？？？？没看懂）

###6.4 数据传送对象
有些类应该当作数据结构来使用，如只有变量域，必要的取值器、赋值器的类；不应该在这类数据结构中塞进业务处理方法，因为这导致了数据结构和对象的混杂。应该创建包含业务处理、隐藏内部数据结构的独立对象

#7. 错误处理
###7.1 使用异常处理而非返回码
###7.3 使用不可控异常
java中可控异常的代价是违反开放/闭合原则：如果在方法中抛出可控异常，就得在catch语句和抛出异常处的每个方法中声明该异常，意味着对软件中较低层级的修改，都将涉及较高层级的修改。可控异常以这种方式破坏了封装

特例模式(special case pattern)

###7.7 别返回Null值
尽量避免返回null值,不如改为抛出异常或者返回特例对象

###7.8 别传递Null值

#8. 边界
###8.2 8.3（缺失）

（....）

#9. 单元测试
###9.1 TDD(测试驱动开发)三定律
- 没有测试之前不要写任何产品代码
- 只编写恰好能够体现一个失败情况的测试代码
- 只编写恰好能通过测试的产品代码

测试与产品代码一起写，测试只比生产代码早写一点点

###9.2 保持测试整洁
测试代码与产品代码一样重要，同样需要按照产品代码的标准保持整洁

###9.3 整洁的测试
可读性

不使用直接对系统进行操作的API，而是打造一套包装这些API的函数和工具代码，可以更方便地进行测试，也便于阅读

###9.4 每个测试一个断言
每个测试函数都应该有且仅有一个断言(assert)，每个测试函数中只测试一个概念

###9.5 F.I.R.S.T
- 快速。测试应该能快速运行
- 独立。测试应该相互独立
- 可重复。测试应该在任何环境中重复通过
- 自足验证。测试应该有布尔值输出，无论是通过还是失败，不应该利用人工操作来确认是否通过，否则会使对失败或成功的判断变得依赖主观
- 及时。应该在产品代码之前及时编写

#10. 类
###10.1 类的组织
先是类变量：依次为公共静态变量，私有静态变量，私有实体变量；然后是函数

###10.2 类应该短小
**单一权责原则(SRP)**：类或模块应该有且仅有一个修改的理由

系统应该由许多短小的类而不是少量巨大的类组成。每一个类封装一个权责，只有一个修改的理由，并与少数其他类一起协同构成系统

**内聚**：方法操作的类变量越多，就越聚合到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性；保持内聚性就会得到很多短小的类

**隔离修改**：降低连接度。 **依赖倒置原则(DIP)**，类应当依赖于抽象而不是依赖于具体细节

**开放-闭合原则(OCP)**：类应当对拓展开放，对修改封闭

#11. 系统
###11.2 将系统的构造与使用分开
软件系统应将启动过程和启动过程之后的运行逻辑分开

(。。。。暂时理解不好)
(。。。。。。。。。)

#12. 迭进
按重要程度排序，软件设计的四条规则：

- 运行所有测试。编写测试并持续运行测试，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计
- 消除重复
- 表达了程序员的意图
- 尽可能减少类和方法的数量（优先级最低）

#14. （一个重构的案例）

#17. （一些规则总结）