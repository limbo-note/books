#2. 线程安全
如果多个线程访问、写入了同一个变量，程序就存在隐患。三种方法修复：  

- 不要跨线程共享变量
- 使变量为不可变的
- 在任何访问变量的时候使用同步

**无状态（不包含域变量也没有引用其它类的域变量）对象**永远是线程安全的  

###2.2 原子性
**竞争条件**：检查再运行(常见于惰性初始化)  

**复合操作**：与原子操作对立  

###2.3 锁
**内部锁**：synchronized块  
`synchronized(lock){ }`  
每个java对象都可以隐式地扮演一个用于同步锁的角色，此内置的锁称为 **内部锁（监视器锁）**。synchronized方法是特殊的synchronized块，它的锁就是方法所在的对象本身  

**重进入**：被线程A占有的锁不能被其它线程同时访问，但是可以被同一线程A同时进入访问；子类和父类中同一个方法的synchronized默认都是取得父类的锁，是同一个锁，可重入

#3. 共享对象
###3.1 可见性
希望确保当一个线程修改了对象的状态后，其他的线程能够真正看到改变  

**没有声明为volatile的64位数值变量(double和long)，在读和写时是非原子操作**  

**锁不仅是关于同步和互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步**  

**volatile变量**：当一个域变量声明为volatile后，编译器与运行时会监视此变量，它是共享的，并且对它的操作不会与其它的内存操作一起被重排序。volatile变量不会缓存在寄存器或缓存在对其它处理器隐藏的地方。所以读一个volatile变量时，总会返回由某一线程所写入的最新值  

**不应过度依赖volatile提供的可见性。依赖volatile变量来控制状态可见性的代码，比使用锁的代码更脆弱，更难理解**  

volatile变量通常被当作标识完成、中断、状态的标记使用。 **锁可以保证可见性与原子性，但volatile变量只能保证可见性**  

###3.2 发布和逸出
发布一个对象，同时也发布了该对象中所有非私有域的对象  

发布一个内部类实例时，发生了逸出——this引用在构造时逸出。可以使用工厂方法防止this引用在构造时逸出

###3.3 线程封闭
ad-hoc线程限制、栈限制、ThreadLocal

###3.4 不可变性
创建后状态不能被修改的对象叫做不可变对象，天生永远是线程安全的

满足如下，一个对象才是不可变的：

- 它的状态不能在创建后再被修改
- 所有域都是final类型
- 被正确创建（创建期间没有发生this引用逸出）

###3.5 安全发布
安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布：  

- 通过静态初始化器初始化对象的引用
- 将它的引用存储到volatile域或者AtomicReference
- 将它的引用存储到正确创建的对象的final域中
- 将它的引用存储到由锁正确保护的域中

#4. 组合对象
###4.1 设计线程安全的类
设计线程安全类的过程应该包括下面三个要素：

- 确定对象状态是由哪些变量构成的
- 确定限制状态变量的不变约束
- 制定一个管理并发访问对象状态的策略

**对象的状态**：如果对象的域都是基本类型的，那么这些域就组成了它的完整状态。如果一个对象的域引用了其他对象，那么它的状态也同时包含了被引用对象的域(如LinkedList的状态包括了所有存储在链表中的节点对象的状态)  

（..........）  

（..............）

#6. 任务执行
###6.1 在线程中执行任务
在生产环境中，“每任务每线程”存在实际缺陷，在创建大量线程时会更突出：

- 线程生命周期的开销。线程的创建和关闭会有开销
- 资源消耗量。如果可运行的线程数多于可用的处理器数，线程将会空闲，大量空闲线程占用更多内存。如果你已经有了足够多的线程保持所有CPU忙碌，那么再创建更多的线程是百害无一利的
- 稳定性。应该限制可创建线程的数目

“每任务每线程”问题在于没有对创建线程的数量进行任何限制，如果有客户端发出大量请求，很容易导致服务器的崩溃

###6.2 Executor框架
在线程池中执行任务，可以重用存在的线程，而不是创建新的线程，可以减小线程创建、消亡时产生的开销。另一个好处，当有请求时，可以重用之前已经存在的线程，响应速度会更快；可以维护安全数量的线程，防止线程过多或过少

通过调用Executor的 **静态工厂方法**创建线程池：

- newFixedThreadPool. 创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到最大长度，之后长度不再变化
- newCachedThreadPool. 创建一个可缓存的线程池，如果当前线程池长度超过了需要，可以灵活地回收；当需求增加，可以灵活地添加新线程，不对长度作限制
- newSingleThreadExecuor. 创建一个单线程化的executor
- newScheduledThreadPool. 创建一个定长线程池，支持定时的以及周期性的任务执行（java5.0后，几乎用此类代替Timer）

**executor的生命周期**：ExecutorService生命周期有三种状态：运行、关闭和终止。创建后初始状态是运行；shutdown方法则停止接受新的任务，同时等待已提交的的任务完成；shutdownNow方法启动强制关闭的过程，尝试取消所有任务；一旦所有任务全部完成后，进入终止状态

###6.3 寻找可强化的并行性
可携带结果的任务：Callable和Future

CompletionService

