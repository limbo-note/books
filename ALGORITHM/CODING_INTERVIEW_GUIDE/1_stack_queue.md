[TOC]

# 一. 设计一个有getMin功能的栈

- pop、push、getMin时间复杂度均为O(1)
- 可以使用现成的栈

同leetcode 155, leetcode方法还有更优

# 二. 由两个栈组成的队列

同leetcode 232, leetcode两种方法

# 三. <u>仅用递归和栈基本操作逆序一个栈</u>

主要是两个递归函数：
1. 移除栈底的元素并返回				
	![](1-1.jpg)
2. 逆序一个栈，递归方法				
	![](1-2.jpg)

# 四. 猫狗队列

猫狗类继承于宠物类，要求：			
	![](1-3.jpg)

常见错误：				
	![](1-4.jpg)

主要思想：
- 用两个队列，一个保存猫一个保存狗
- 两个队列中的每个实例都加上一个计数项，用于判断不同队列中的队首元素到底是谁先入队

	![](1-5.jpg)

# 五. 用一个栈对另一个栈进行排序

仅用一个栈B完成对另一个栈A的栈顶至栈底的从大到小排序

主要思想：
- 重点在于想把栈A的数据弹出，先在栈B中形成从小到大的顺序，再逐一压回栈A即可
- 所以，维护栈B元素一直为从小到大的顺序，若从栈A中弹出的元素小于或等于栈B顶，直接压入B；若大于，则先将栈B的元素压回A，将此元素放到相应位置，再将栈A元素压回B

	![](1-6.jpg)

# 六. 栈解决汉诺塔问题

要求：
- 递归的方法
- 非递归的方法，用栈模拟三个塔

递归:
1. （递归终止条件）：当只有一个块时，直接移动
2. 当N个块需要移动，且只需移动一步，则为（从左到中举例）：
	1. 递归将第1~N-1从左到右
	2. 将第N从左到中
	3. 递归将第1~N-1从右到中
3. 当N个块需要移动，但需移动两步，则为（从左到右举例）：
	1. 递归将1~N-1从左到右
	2. 将第N从左到中
	3. 递归将1~N-1从右到左
	4. 将第N从中到右
	5. 递归将1~N-1从左到右

非递归:
1. 主要思想：
	1. 小压大原则
	2. 相邻不可逆原则（相邻步骤一定不是正好相逆的，否则不是最优）
	3. 每一个步骤，L->M，M->R，M->L, R->M的四个操作中，只有一个符合上述两个原则，故每次只有一个确定的移动方案，过程是完全确定的
	4. 左中右各一个栈，移动就是出栈入栈的过程

	![](1-7.jpg)

# 七. 生成窗口最大值数组

同**leetcode 239**

![](1-8.jpg)
![](1-9.jpg)

主要思想：
1. 双端队列，维持队头为窗口最大值（以下均保存下标）（若队头过期，则弹出）
2. 每新扫描一个数，则判断：
	1. 若比队尾数还小，则直接放入队尾
	2. 若比队尾数大，则从队尾弹出比其小（或等）的数，直到队尾数比其大，并加入队尾
3. 即队列保持队头到队尾从大至小的顺序排列 

![](1-10.jpg)

# 八. <u>构造数组的MaxTree</u>

### 基础问题：找到不重复数组里每个数的左右两边最近的比其大的数

利用栈：

1. 从数组开始向右遍历，若当前数比栈顶元素小或栈顶无元素，则直接入栈，遍历下一个
2. 若比栈顶大，则可确定栈顶元素的左右最近的比其大的数，并将其出栈。左边的数为栈顶元素栈中的下一个数，右边的数则为使其出栈的那个数



确定好上述结果后，即可构建MaxTree：

- 对每个数，在其左右两边最近的大数中，其父节点是两个数中较小的那个（若只有一个，则为这个）。可证明（先证明其是树，不是森林；再证明其是二叉树不是多叉树）
- 若两边都无大数，则其为根节点

# 九. 最大子矩阵的大小

求全是1的最大子矩阵（N×M）：

将矩阵的每一行作为底，求其每一列的最长1值矩阵的长度，然后利用左右两边最近的小数的方法，可求出每列能扩展的最大面积（O(M)），每行中最大的面积可求出，再得出全矩阵的最大值（O(N×M)）

# 十. <u>极差小于等于某个值的子数组数量</u>

### 基础问题：生成窗口最大值数组

以第七题为基础问题，以O(1)的时间更新数组的最大值和最小值，以最大值为例：

- 当数组拓展时，将当前数加入队列右边，并更新右边元素（比其小的数出队，直到遇见比其大的数，入队），并取最左边元素，更新最大值
- 当数组缩小时，检测左边元素是否过期，并取最左边元素，更新最大值
- 操作都是O(1)的复杂度



该题建立在此基础问题上：

- 维护两个如上的队列，一个求最大值，一个求最小值
- 子数组右端开始不断向右拓展，每拓展一次，最大值和最小值都更新，判断其是否满足条件<=num。直至不满足，假设此时数组为arr[i~k]，则以i为左端的子数组arr[i~k-1],arr[i~k-2],...,arr[i~i]全部满足条件，arr[i~k],arr[i~k+1]....全部不满足条件，这就确定了以i为左端的子数组数量
- 此时左端向右进行拓展，计算以i+1为左端的子数组数量，同步骤2，直至数组尾部

