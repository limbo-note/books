# 6. 访问权限控制
java可运行程序是一组可以打包并压缩为一个jar文件的class文件，java解释器负责这些文件的查找、装载和解释  

java解释器查找class过程：获得CLASSPATH；从根目录开始，获取包的名称并将句点替换成反斜杠，与CLASSPATH结合得到一些目录；在这些目录中查找class文件

### 6.4 类的访问权限
编译单元内没有public类也是可能的，这时可以随意对文件命名  

可以将所有的构造器指定为private来阻止直接创建此类的实例。但可以有两种方法使用此类：  
1. 构造一个public的static方法，它创建一个新的类对象实例并返回引用。2. 单例模式 

# 7. 复用类
组合( **has-a** )和继承( **is-a** )  

### 7.1 组合语法
将对象引用置于新类中

### 7.3 代理
基于组合和继承之间

与C++不同，Java的子类重载任何方法并不会屏蔽其父类原有的方法  

### 7.7 向上转型
形参为父类，实际传入的参数为子类

### 7.8 final
当对象的引用定义为final时，则无法把它改为指向另一个对象，但是对象本身是可以被修改的

final定义的变量必须在定义时初始化，或者在所有构造器中被初始化

final参数：无法被修改的参数

final方法：防止被重写  

private方法被隐式指定为final，因为private方法无法被子类重写  

final类：无法被继承

### 7.9 类的加载
class文件只在被用到时才会被加载，通常指的是创建第一个对象，或者首次访问static变量、方法时  

在加载子类时，父类也会自动被加载

# 8. 多态
动态绑定，使得只要遍历父类对象数组并进行相同的调用，就能自动正确地调用到其子类重写过的方法 

**构造器调用顺序(PDF192)：**  
1. 首先给将要创建的对象的存储空间全部初始化成0  
2. 按继承从上至下的顺序，调用所有基类构造器  
3. 按声明的顺序完成自身类的初始化动作，包括对象的初始化  
4. 调用自身类的构造器  

### 8.4 协变返回类型
在子类中被覆盖的方法可以返回父类中此方法返回类型的子类型

# 9. 接口
### 9.2 接口
接口可以包含变量，但是都隐式自动地是static和final的  
接口中不可以有static代码块  
接口中定义的方法必须为public（若没有显示声明为public，则自动成为public），否则将只有包访问权限，导致在继承的过程中，方法的可访问权限被降低了

### 9.3 完全解耦
接口提高复用性

### 9.4 java中的多重继承
即可以同时实现多个接口，但最多只能继承于一个父类

### 9.5 接口也可继承
接口的继承extends后可接多个接口，即`interface A extends B, C...`  

应尽量避免在继承多个接口时，多个接口中出现方法名相同而返回值不同的情况  

### 9.6 适配接口
接口的一种常见用法就是使用策略设计模式，适配器设计模式  

### 9.8 嵌套接口
(........）

### 9.9 工厂设计模式
(........)

# 10. 内部类
### 10.1 创建内部类
如果想在外部类非静态方法之外的地方创建内部类，需要OuterClass.InnerClass明确指明对象类型  

### 10.2 链接到外部类
“迭代器”设计模式：内部类拥有其外部类的所有元素的访问权  

.this：内部类中生成对外部类对象的引用，需要使用外部类名字后紧跟.this  
.new：在外部类非静态方法之外的地方 **直接** 创建内部类，必须使用外部类对象来创建内部类对象，并使用.new  

### 10.4 （......）
（......）
